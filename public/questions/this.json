[
  {
    "id": "q1_this_basic",
    "category": "this",
    "difficulty": "easy",
    "type": "code-output",
    "title": "Basic This Binding",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'JS',\n  getName: function() {\n    return this.name;\n  }\n};\n\nconsole.log(obj.getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "null"
    ],
    "correctAnswer": 0,
    "explanation": "When a function is called as a method (obj.method()), this refers to the object that owns the method.",
    "tags": ["this", "method", "binding"],
    "created_at": 1733046300000
  },
  {
    "id": "q2_this_lost",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Lost This Context",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'JS',\n  getName: function() {\n    return this.name;\n  }\n};\n\nconst getName = obj.getName;\nconsole.log(getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Window object name"
    ],
    "correctAnswer": 1,
    "explanation": "When you extract a method and call it as a standalone function, this loses its binding. In strict mode, this is undefined. In non-strict mode, it's the global object.",
    "tags": ["this", "context", "lost"],
    "nonStrictMode": true,
    "created_at": 1733046301000
  },
  {
    "id": "q3_this_arrow",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Arrow Functions and This",
    "question": "What is the output?",
    "code": "const obj = {\n  name: 'JS',\n  getName: () => {\n    return this.name;\n  }\n};\n\nconsole.log(obj.getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Window object name"
    ],
    "correctAnswer": 1,
    "explanation": "Arrow functions don't have their own this. They inherit this from the enclosing lexical scope, which in this case is the global scope.",
    "tags": ["this", "arrow-functions"],
    "created_at": 1733046302000
  },
  {
    "id": "q4_this_bind",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Using Bind",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'JS',\n  getName: function() {\n    return this.name;\n  }\n};\n\nconst getName = obj.getName.bind(obj);\nconsole.log(getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "null"
    ],
    "correctAnswer": 0,
    "explanation": "bind() creates a new function with this permanently bound to the specified object. Even when called standalone, this remains bound.",
    "tags": ["this", "bind"],
    "created_at": 1733046303000
  },
  {
    "id": "q5_this_call_apply",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Call and Apply",
    "question": "What is the output?",
    "code": "function greet(greeting) {\n  return greeting + ' ' + this.name;\n}\n\nconst obj = { name: 'JS' };\nconsole.log(greet.call(obj, 'Hello'));",
    "options": [
      "Hello JS",
      "Hello undefined",
      "ReferenceError",
      "undefined JS"
    ],
    "correctAnswer": 0,
    "explanation": "call() and apply() allow you to explicitly set this when calling a function. call() takes arguments individually, apply() takes an array.",
    "tags": ["this", "call", "apply"],
    "created_at": 1733046304000
  },
  {
    "id": "q6_this_constructor",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "This in Constructor",
    "question": "What will be logged?",
    "code": "function Person(name) {\n  this.name = name;\n}\n\nconst person = new Person('JS');\nconsole.log(person.name);",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Person"
    ],
    "correctAnswer": 0,
    "explanation": "When a function is called with new, this refers to the newly created instance. The constructor sets properties on this instance.",
    "tags": ["this", "constructor", "new"],
    "created_at": 1733046305000
  },
  {
    "id": "q7_this_nested",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Nested Functions",
    "question": "What is the output?",
    "code": "const obj = {\n  name: 'JS',\n  outer: function() {\n    console.log(this.name);\n    function inner() {\n      console.log(this.name);\n    }\n    inner();\n  }\n};\n\nobj.outer();",
    "options": [
      "JS, JS",
      "JS, undefined",
      "undefined, undefined",
      "ReferenceError"
    ],
    "correctAnswer": 1,
    "explanation": "inner() is called as a standalone function, so this is undefined (strict mode) or the global object. Only outer() has this bound to obj.",
    "tags": ["this", "nested", "function"],
    "created_at": 1733046306000
  },
  {
    "id": "q8_this_arrow_nested",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Arrow Function in Method",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'JS',\n  outer: function() {\n    console.log(this.name);\n    const inner = () => {\n      console.log(this.name);\n    };\n    inner();\n  }\n};\n\nobj.outer();",
    "options": [
      "JS, JS",
      "JS, undefined",
      "undefined, undefined",
      "ReferenceError"
    ],
    "correctAnswer": 0,
    "explanation": "Arrow functions inherit this from the enclosing scope. Since outer() has this bound to obj, inner() also has this bound to obj.",
    "tags": ["this", "arrow-functions", "nested"],
    "created_at": 1733046307000
  },
  {
    "id": "q9_this_class",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "This in Class Methods",
    "question": "What is the output?",
    "code": "class Person {\n  constructor(name) {\n    this.name = name;\n  }\n  getName() {\n    return this.name;\n  }\n}\n\nconst person = new Person('JS');\nconsole.log(person.getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Person"
    ],
    "correctAnswer": 0,
    "explanation": "When a method is called on an instance (person.getName()), this refers to that instance. Note: class methods are NOT automatically bound - extracting them loses the context.",
    "tags": ["this", "class", "methods"],
    "created_at": 1733046308000
  },
  {
    "id": "q10_this_strict",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Strict Mode and This",
    "question": "What happens in strict mode?",
    "code": "'use strict';\n\nfunction test() {\n  return this;\n}\n\nconsole.log(test());",
    "options": [
      "Returns the global object",
      "Returns undefined",
      "Returns null",
      "Throws ReferenceError"
    ],
    "correctAnswer": 1,
    "explanation": "In strict mode, when a function is called without a context, this is undefined instead of the global object. This prevents accidental global variable creation.",
    "tags": ["this", "strict-mode"],
    "created_at": 1733046309000
  },
  {
    "id": "q11_this_settimeout",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "This in setTimeout",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'JS',\n  getName: function() {\n    setTimeout(function() {\n      console.log(this.name);\n    }, 0);\n  }\n};\n\nobj.getName();",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Nothing"
    ],
    "correctAnswer": 1,
    "explanation": "The callback function passed to setTimeout loses its this context. It's called as a standalone function, so this is undefined or the global object.",
    "tags": ["this", "settimeout", "callback"],
    "created_at": 1733046310000
  },
  {
    "id": "q12_this_prototype",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "This in Prototype Methods",
    "question": "What is the output?",
    "code": "function Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.getName = function() {\n  return this.name;\n};\n\nconst person = new Person('JS');\nconsole.log(person.getName());",
    "options": [
      "JS",
      "undefined",
      "ReferenceError",
      "Person"
    ],
    "correctAnswer": 0,
    "explanation": "When a method is called on an instance, this refers to that instance, regardless of whether the method is defined on the instance or the prototype.",
    "tags": ["this", "prototype", "inheritance"],
    "created_at": 1733046311000
  },
  {
    "id": "q13_this_class_field_arrow",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Class Field Arrow Functions",
    "question": "What will be logged?",
    "code": "class Button {\n  text = 'Click me';\n  handleClick = () => {\n    console.log(this.text);\n  };\n}\n\nconst btn = new Button();\nconst handler = btn.handleClick;\nhandler();",
    "options": [
      "Click me",
      "undefined",
      "ReferenceError",
      "null"
    ],
    "correctAnswer": 0,
    "explanation": "Arrow functions in class fields are bound to the instance at creation time. Even when extracted, handler() retains 'this' bound to btn.",
    "tags": ["this", "class-fields", "arrow-functions"],
    "created_at": 1733046312000
  },
  {
    "id": "q14_this_new_target",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "new.target Meta-property",
    "question": "What is the output?",
    "code": "function Base() {\n  console.log(new.target?.name);\n}\n\nfunction Derived() {\n  Base.call(this);\n}\n\nnew Base();\nnew Derived();\nBase();",
    "options": [
      "Base, Derived, undefined",
      "Base, Base, undefined",
      "Base, undefined, undefined",
      "Base, Derived, Base"
    ],
    "correctAnswer": 2,
    "explanation": "new.target is set when called with 'new'. Base.call(this) doesn't set new.target. Regular function call has new.target as undefined.",
    "tags": ["this", "new.target", "constructor"],
    "created_at": 1733046313000
  },
  {
    "id": "q15_this_symbol_unscopables",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Explicit Binding Precedence",
    "question": "What will be logged?",
    "code": "function greet() {\n  console.log(this.name);\n}\n\nconst obj = { name: 'obj' };\nconst bound = greet.bind({ name: 'bound' });\n\nbound.call(obj);\nbound.apply(obj);\nnew bound();",
    "options": [
      "obj, obj, undefined",
      "bound, bound, undefined",
      "bound, obj, undefined",
      "obj, obj, bound"
    ],
    "correctAnswer": 1,
    "explanation": "bind() creates a function with permanently bound this. call() and apply() cannot override it. 'new' creates a new object, ignoring the bound this.",
    "tags": ["this", "bind", "call", "apply", "new"],
    "created_at": 1733046314000
  },
  {
    "id": "q16_this_proxy_handler",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "This in Proxy Handler",
    "question": "What is the output?",
    "code": "const obj = {\n  name: 'original',\n  getName() {\n    return this.name;\n  }\n};\n\nconst proxy = new Proxy(obj, {\n  get(target, prop, receiver) {\n    if (prop === 'name') return 'proxied';\n    return Reflect.get(target, prop, receiver);\n  }\n});\n\nconsole.log(proxy.getName());",
    "options": [
      "original",
      "proxied",
      "undefined",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "When getName() is called on the proxy, 'this' is the proxy. The proxy intercepts this.name and returns 'proxied'.",
    "tags": ["this", "proxy", "reflect"],
    "created_at": 1733046315000
  },
  {
    "id": "q17_this_dom_events",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "This in Event Handlers",
    "question": "In a browser, what does 'this' refer to?",
    "code": "button.addEventListener('click', function() {\n  console.log(this === button);\n});\n\nbutton.addEventListener('click', () => {\n  console.log(this === window);\n});",
    "options": [
      "true, true",
      "true, false",
      "false, true",
      "false, false"
    ],
    "correctAnswer": 0,
    "explanation": "In regular function handlers, 'this' is the element. Arrow functions inherit 'this' from enclosing scope (global/window in browsers at top level).",
    "tags": ["this", "dom", "event-handlers"],
    "created_at": 1733046316000
  },
  {
    "id": "q18_this_getter_setter",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "This in Getters/Setters",
    "question": "What will be logged?",
    "code": "const obj = {\n  _value: 10,\n  get value() {\n    return this._value;\n  },\n  set value(v) {\n    this._value = v;\n  }\n};\n\nconst { value } = obj;\nconst getter = Object.getOwnPropertyDescriptor(obj, 'value').get;\n\nconsole.log(value);\nconsole.log(getter());",
    "options": [
      "10, 10",
      "10, undefined",
      "undefined, 10",
      "undefined, undefined"
    ],
    "correctAnswer": 1,
    "explanation": "Destructuring { value } calls the getter with 'this' as obj, returning 10. Extracted getter() called standalone has no 'this', so _value is undefined.",
    "tags": ["this", "getter", "setter", "destructuring"],
    "created_at": 1733046317000
  },
  {
    "id": "q19_this_foreach_context",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "forEach with thisArg",
    "question": "What will be logged?",
    "code": "const obj = {\n  multiplier: 2,\n  multiply(arr) {\n    return arr.map(function(x) {\n      return x * this.multiplier;\n    }, this);\n  }\n};\n\nconsole.log(obj.multiply([1, 2, 3]));",
    "options": [
      "[2, 4, 6]",
      "[NaN, NaN, NaN]",
      "[undefined, undefined, undefined]",
      "TypeError"
    ],
    "correctAnswer": 0,
    "explanation": "Array methods like map accept a second argument (thisArg) to set 'this' for the callback. Passing 'this' binds the callback to obj.",
    "tags": ["this", "array-methods", "thisarg"],
    "created_at": 1733046318000
  },
  {
    "id": "q20_this_method_chaining",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Method Chaining with This",
    "question": "What is the output?",
    "code": "const calculator = {\n  value: 0,\n  add(n) { this.value += n; return this; },\n  multiply(n) { this.value *= n; return this; },\n  getValue() { return this.value; }\n};\n\nconsole.log(\n  calculator.add(5).multiply(2).add(3).getValue()\n);",
    "options": [
      "13",
      "16",
      "10",
      "NaN"
    ],
    "correctAnswer": 0,
    "explanation": "Each method returns 'this', enabling chaining. Operations: 0+5=5, 5*2=10, 10+3=13. This pattern is common in fluent APIs.",
    "tags": ["this", "chaining", "fluent-api"],
    "created_at": 1733046319000
  },
  {
    "id": "q21_this_arrow_email",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Arrow Function Method",
    "question": "What will be logged?",
    "code": "const user = {\n  email: 'my@email.com',\n  updateEmail: email => {\n    this.email = email;\n  }\n};\n\nuser.updateEmail('new@email.com');\nconsole.log(user.email);",
    "options": [
      "'new@email.com'",
      "'my@email.com'",
      "undefined",
      "ReferenceError"
    ],
    "correctAnswer": 1,
    "explanation": "Arrow functions don't bind their own this. this refers to the enclosing scope (global/undefined). user.email is unchanged.",
    "tags": ["this", "arrow-function", "method"],
    "created_at": 1733046320000
  },
  {
    "id": "q22_this_function_constructor",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Constructor Without new",
    "question": "What happens?",
    "code": "function Person(name) {\n  this.name = name;\n}\n\nconst person = Person('Alice');\nconsole.log(person);\nconsole.log(typeof window !== 'undefined' ? window.name : global.name);",
    "options": [
      "Person { name: 'Alice' }, undefined",
      "undefined, 'Alice'",
      "{ name: 'Alice' }, undefined",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "Without new, Person() returns undefined. this refers to global object, polluting it with name='Alice'.",
    "tags": ["this", "constructor", "new"],
    "created_at": 1733046321000
  },
  {
    "id": "q23_this_bind_twice",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Double Bind",
    "question": "What is the output?",
    "code": "function greet() {\n  return this.name;\n}\n\nconst obj1 = { name: 'Alice' };\nconst obj2 = { name: 'Bob' };\n\nconst bound = greet.bind(obj1).bind(obj2);\nconsole.log(bound());",
    "options": [
      "'Bob'",
      "'Alice'",
      "undefined",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "bind() can only bind once. The second bind() has no effect. The function remains bound to obj1 ('Alice').",
    "tags": ["this", "bind", "immutable"],
    "created_at": 1733046322000
  },
  {
    "id": "q24_this_callback_array",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Array Method Callback",
    "question": "What will be logged?",
    "code": "const obj = {\n  values: [1, 2, 3],\n  multiplier: 2,\n  getMultiplied() {\n    return this.values.map(function(val) {\n      return val * this.multiplier;\n    });\n  }\n};\n\nconsole.log(obj.getMultiplied());",
    "options": [
      "[2, 4, 6]",
      "[NaN, NaN, NaN]",
      "[undefined, undefined, undefined]",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "Regular function callback loses this context. this.multiplier is undefined. undefined * number = NaN for each element.",
    "tags": ["this", "callback", "array-methods"],
    "created_at": 1733046323000
  },
  {
    "id": "q25_this_implicit_binding",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Implicit Binding Loss",
    "question": "What is the output?",
    "code": "const obj = {\n  name: 'Alice',\n  greet() {\n    return this.name;\n  }\n};\n\nconst greet = obj.greet;\nconst objGreet = obj.greet.bind(obj);\n\nconsole.log(greet());\nconsole.log(objGreet());\nconsole.log((obj.greet)());",
    "options": [
      "undefined, 'Alice', 'Alice'",
      "'Alice', 'Alice', 'Alice'",
      "undefined, 'Alice', undefined",
      "'Alice', undefined, 'Alice'"
    ],
    "correctAnswer": 0,
    "explanation": "greet() loses context (undefined). objGreet() is bound. (obj.greet)() still has implicit binding because obj is the caller.",
    "tags": ["this", "implicit-binding", "parentheses"],
    "created_at": 1733046324000
  },
  {
    "id": "q26_this_nested_arrow",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Nested Arrow Functions",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'Object',\n  outer: function() {\n    const inner = () => {\n      const deepInner = () => {\n        console.log(this.name);\n      };\n      deepInner();\n    };\n    inner();\n  }\n};\n\nobj.outer();",
    "options": [
      "undefined",
      "'Object'",
      "ReferenceError",
      "''(empty string)"
    ],
    "correctAnswer": 1,
    "explanation": "Arrow functions inherit this from their lexical scope. Both inner and deepInner inherit this from outer(), which is bound to obj.",
    "tags": ["this", "arrow-function", "nested"],
    "created_at": 1733046325000
  },
  {
    "id": "q27_this_computed_method",
    "category": "this",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Computed Method Name",
    "question": "What is the output?",
    "code": "const methodName = 'greet';\nconst obj = {\n  name: 'Alice',\n  [methodName]() {\n    return this.name;\n  }\n};\n\nconsole.log(obj.greet());\nconsole.log(obj[methodName]());",
    "options": [
      "'Alice', undefined",
      "'Alice', 'Alice'",
      "undefined, 'Alice'",
      "Error, Error"
    ],
    "correctAnswer": 1,
    "explanation": "Computed method names work like regular methods. Both obj.greet() and obj[methodName]() call the same method with this bound to obj.",
    "tags": ["this", "computed", "method"],
    "created_at": 1733046326000
  },
  {
    "id": "q28_this_promise_then",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "this in Promise.then",
    "question": "What will be logged?",
    "code": "const obj = {\n  name: 'Alice',\n  async getName() {\n    return this.name;\n  },\n  getNameThen() {\n    return Promise.resolve().then(function() {\n      return this.name;\n    });\n  }\n};\n\nobj.getName().then(console.log);\nobj.getNameThen().then(console.log);",
    "options": [
      "'Alice', 'Alice'",
      "'Alice', undefined",
      "undefined, undefined",
      "undefined, 'Alice'"
    ],
    "correctAnswer": 1,
    "explanation": "async functions preserve this ('Alice'). Regular function in .then() loses this context (undefined). Use arrow function to fix.",
    "tags": ["this", "promise", "async"],
    "created_at": 1733046327000
  },
  {
    "id": "q29_this_call_null",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "call with null",
    "question": "What is the output? (non-strict mode)",
    "code": "function getName() {\n  return this.name;\n}\n\nconst obj = { name: 'Alice' };\n\nconsole.log(getName.call(null));\nconsole.log(getName.call(obj));",
    "options": [
      "undefined, 'Alice'",
      "null, 'Alice'",
      "'', 'Alice' (or window.name)",
      "Error, 'Alice'"
    ],
    "correctAnswer": 2,
    "explanation": "In non-strict mode, call(null) sets this to global object (window). window.name is usually '' or the window name. In strict mode, it's null.",
    "tags": ["this", "call", "null"],
    "nonStrictMode": true,
    "created_at": 1733046328000
  },
  {
    "id": "q30_this_super_this",
    "category": "this",
    "difficulty": "hard",
    "type": "code-output",
    "title": "super and this",
    "question": "What will be logged?",
    "code": "class Parent {\n  constructor() {\n    this.name = 'Parent';\n  }\n  getName() {\n    return this.name;\n  }\n}\n\nclass Child extends Parent {\n  constructor() {\n    super();\n    this.name = 'Child';\n  }\n  getParentName() {\n    return super.getName();\n  }\n}\n\nconst child = new Child();\nconsole.log(child.getParentName());",
    "options": [
      "'Parent'",
      "'Child'",
      "undefined",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "super.getName() calls Parent's method but this still refers to the child instance. this.name is 'Child' after constructor runs.",
    "tags": ["this", "super", "inheritance"],
    "created_at": 1733046329000
  }
]

