[
  {
    "id": "q1_async_promise_basic",
    "category": "async",
    "difficulty": "easy",
    "type": "code-output",
    "title": "Basic Promise",
    "question": "What will be logged?",
    "code": "const promise = new Promise((resolve) => {\n  console.log('1');\n  resolve('2');\n});\n\npromise.then(console.log);\nconsole.log('3');",
    "options": [
      "1, 2, 3",
      "1, 3, 2",
      "3, 1, 2",
      "2, 1, 3"
    ],
    "correctAnswer": 1,
    "explanation": "The Promise executor runs synchronously, logging '1'. The .then() callback is asynchronous (microtask), so '3' logs before '2'.",
    "tags": ["async", "promise", "microtask"],
    "created_at": 1733046200000
  },
  {
    "id": "q2_async_await_basic",
    "category": "async",
    "difficulty": "easy",
    "type": "code-output",
    "title": "Basic Async/Await",
    "question": "What is the output?",
    "code": "async function test() {\n  const result = await Promise.resolve('done');\n  console.log(result);\n}\n\ntest();\nconsole.log('start');",
    "options": [
      "done, start",
      "start, done",
      "done",
      "start"
    ],
    "correctAnswer": 1,
    "explanation": "await pauses the function execution, but doesn't block the main thread. 'start' logs first, then 'done' after the promise resolves.",
    "tags": ["async", "await"],
    "created_at": 1733046201000
  },
  {
    "id": "q3_async_promise_all",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.all",
    "question": "What will be logged?",
    "code": "const p1 = Promise.resolve(1);\nconst p2 = Promise.resolve(2);\nconst p3 = Promise.resolve(3);\n\nPromise.all([p1, p2, p3]).then(console.log);",
    "options": [
      "[1, 2, 3]",
      "1, 2, 3",
      "[Promise, Promise, Promise]",
      "undefined"
    ],
    "correctAnswer": 0,
    "explanation": "Promise.all resolves with an array of all resolved values in the same order as the input promises.",
    "tags": ["async", "promise.all"],
    "created_at": 1733046202000
  },
  {
    "id": "q4_async_promise_all_reject",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.all with Rejection",
    "question": "What happens?",
    "code": "const p1 = Promise.resolve(1);\nconst p2 = Promise.reject('error');\nconst p3 = Promise.resolve(3);\n\nPromise.all([p1, p2, p3])\n  .then(console.log)\n  .catch(console.error);",
    "options": [
      "Logs [1, 3]",
      "Logs error",
      "Logs [1, 'error', 3]",
      "Nothing happens"
    ],
    "correctAnswer": 1,
    "explanation": "Promise.all rejects immediately if any promise rejects. It doesn't wait for other promises to complete.",
    "tags": ["async", "promise.all", "error"],
    "created_at": 1733046203000
  },
  {
    "id": "q5_async_promise_allSettled",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.allSettled",
    "question": "What is the result?",
    "code": "const p1 = Promise.resolve(1);\nconst p2 = Promise.reject('error');\n\nPromise.allSettled([p1, p2]).then(console.log);",
    "options": [
      "[1, 'error']",
      "Rejects with 'error'",
      "[{status: 'fulfilled', value: 1}, {status: 'rejected', reason: 'error'}]",
      "Nothing"
    ],
    "correctAnswer": 2,
    "explanation": "Promise.allSettled waits for all promises to settle (resolve or reject) and returns an array of result objects with status and value/reason.",
    "tags": ["async", "promise.allsettled"],
    "created_at": 1733046204000
  },
  {
    "id": "q6_async_promise_race",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.race",
    "question": "What will be logged?",
    "code": "const fast = Promise.resolve('fast');\nconst slow = new Promise(resolve => setTimeout(() => resolve('slow'), 100));\n\nPromise.race([fast, slow]).then(console.log);",
    "options": [
      "fast",
      "slow",
      "Both",
      "Nothing"
    ],
    "correctAnswer": 0,
    "explanation": "Promise.race resolves or rejects with the first promise that settles. Since fast resolves immediately, it wins the race.",
    "tags": ["async", "promise.race"],
    "created_at": 1733046205000
  },
  {
    "id": "q7_async_await_error",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Error Handling with Async/Await",
    "question": "What will be logged?",
    "code": "async function test() {\n  try {\n    await Promise.reject('error');\n  } catch (e) {\n    console.log(e);\n  }\n}\n\ntest();",
    "options": [
      "error",
      "Unhandled promise rejection",
      "undefined",
      "Nothing"
    ],
    "correctAnswer": 0,
    "explanation": "When a promise rejects in an async function, it throws an exception that can be caught with try/catch.",
    "tags": ["async", "await", "error-handling"],
    "created_at": 1733046206000
  },
  {
    "id": "q8_async_await_sequential",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Sequential vs Parallel",
    "question": "Which approach is faster?",
    "code": "// Approach A\nasync function sequential() {\n  await fetch('/api/1');\n  await fetch('/api/2');\n  await fetch('/api/3');\n}\n\n// Approach B\nasync function parallel() {\n  await Promise.all([\n    fetch('/api/1'),\n    fetch('/api/2'),\n    fetch('/api/3')\n  ]);\n}",
    "options": [
      "Sequential is faster",
      "Parallel is faster",
      "They are the same speed",
      "Depends on network speed"
    ],
    "correctAnswer": 1,
    "explanation": "Parallel execution (Promise.all) runs all requests concurrently, while sequential waits for each to complete. Parallel is typically faster.",
    "tags": ["async", "performance", "parallel"],
    "created_at": 1733046207000
  },
  {
    "id": "q9_async_promise_chain",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise Chaining",
    "question": "What is the output?",
    "code": "Promise.resolve(1)\n  .then(val => val + 1)\n  .then(val => val * 2)\n  .then(console.log);",
    "options": [
      "1",
      "2",
      "4",
      "undefined"
    ],
    "correctAnswer": 2,
    "explanation": "Each .then() receives the return value from the previous one. 1 → +1 = 2 → *2 = 4.",
    "tags": ["async", "promise", "chain"],
    "created_at": 1733046208000
  },
  {
    "id": "q10_async_await_return",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Returning from Async Function",
    "question": "What will be logged?",
    "code": "async function getValue() {\n  return Promise.resolve(42);\n}\n\ngetValue().then(console.log);",
    "options": [
      "42",
      "Promise {<resolved: 42>}",
      "undefined",
      "Error"
    ],
    "correctAnswer": 0,
    "explanation": "If you return a promise from an async function, it's automatically unwrapped. The function returns the resolved value, not the promise itself.",
    "tags": ["async", "return", "promise"],
    "created_at": 1733046209000
  },
  {
    "id": "q11_async_promise_constructor",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Promise Constructor",
    "question": "What happens?",
    "code": "new Promise((resolve, reject) => {\n  resolve(1);\n  reject(2);\n}).then(console.log).catch(console.error);",
    "options": [
      "Logs 1",
      "Logs 2",
      "Logs both 1 and 2",
      "Nothing"
    ],
    "correctAnswer": 0,
    "explanation": "Once a promise is settled (resolved or rejected), subsequent resolve/reject calls are ignored. The first resolve(1) settles the promise.",
    "tags": ["async", "promise", "constructor"],
    "created_at": 1733046210000
  },
  {
    "id": "q12_async_await_loop",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Async in Loops",
    "question": "What is the execution order?",
    "code": "async function process(items) {\n  for (const item of items) {\n    await processItem(item);\n  }\n}\n\nasync function processItem(item) {\n  console.log(item);\n  await Promise.resolve();\n}\n\nprocess([1, 2, 3]);",
    "options": [
      "1, 2, 3 (sequential)",
      "1, 2, 3 (parallel)",
      "3, 2, 1",
      "Non-deterministic"
    ],
    "correctAnswer": 0,
    "explanation": "Using await in a for...of loop processes items sequentially. Each iteration waits for the previous one to complete.",
    "tags": ["async", "await", "loop"],
    "created_at": 1733046211000
  },
  {
    "id": "q13_async_promise_any",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Promise.any Behavior",
    "question": "What will be logged?",
    "code": "const p1 = Promise.reject('error1');\nconst p2 = new Promise(resolve => setTimeout(() => resolve('success'), 100));\nconst p3 = Promise.reject('error2');\n\nPromise.any([p1, p2, p3])\n  .then(console.log)\n  .catch(e => console.log(e.errors));",
    "options": [
      "['error1', 'error2']",
      "success",
      "error1",
      "AggregateError"
    ],
    "correctAnswer": 1,
    "explanation": "Promise.any resolves with the first fulfilled promise. Even though p1 and p3 reject immediately, p2 fulfills after 100ms, so 'success' is logged.",
    "tags": ["async", "promise.any"],
    "created_at": 1733046212000
  },
  {
    "id": "q14_async_unhandled_rejection",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Unhandled Promise Rejection",
    "question": "What happens when this code runs?",
    "code": "async function test() {\n  const p = Promise.reject('error');\n  await new Promise(r => setTimeout(r, 1000));\n  try {\n    await p;\n  } catch (e) {\n    console.log('Caught:', e);\n  }\n}",
    "options": [
      "Caught: error",
      "Unhandled rejection warning, then 'Caught: error'",
      "Only unhandled rejection warning",
      "Nothing happens"
    ],
    "correctAnswer": 1,
    "explanation": "The promise rejects immediately but isn't awaited until after 1 second. Most JS environments emit an unhandledRejection warning, but then catch it.",
    "tags": ["async", "unhandled-rejection", "warning"],
    "created_at": 1733046213000
  },
  {
    "id": "q15_async_promise_finally",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.finally Behavior",
    "question": "What is the output?",
    "code": "Promise.resolve('success')\n  .then(val => {\n    console.log(val);\n    return 'then';\n  })\n  .finally(() => {\n    console.log('finally');\n    return 'finally';\n  })\n  .then(console.log);",
    "options": [
      "success, finally, finally",
      "success, finally, then",
      "success, then, finally",
      "success, finally, undefined"
    ],
    "correctAnswer": 1,
    "explanation": "finally() doesn't receive or modify the resolved value. It passes through the previous value ('then'). The return value of finally is ignored.",
    "tags": ["async", "promise.finally"],
    "created_at": 1733046214000
  },
  {
    "id": "q16_async_thenable",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Thenable Objects",
    "question": "What will be logged?",
    "code": "const thenable = {\n  then(resolve, reject) {\n    console.log('then called');\n    setTimeout(() => resolve(42), 100);\n  }\n};\n\nasync function test() {\n  console.log('before');\n  const result = await thenable;\n  console.log(result);\n}\n\ntest();\nconsole.log('after');",
    "options": [
      "before, after, then called, 42",
      "before, then called, after, 42",
      "then called, before, after, 42",
      "before, then called, 42, after"
    ],
    "correctAnswer": 0,
    "explanation": "await works with any thenable, but the then method is called asynchronously as a microtask. The function returns control first, so 'after' logs before 'then called'. Then after 100ms, the promise resolves and logs 42.",
    "tags": ["async", "thenable", "await"],
    "created_at": 1733046215000
  },
  {
    "id": "q17_async_top_level_await",
    "category": "async",
    "difficulty": "hard",
    "type": "multiple-choice",
    "title": "Top-Level Await",
    "question": "Where can top-level await be used?",
    "code": "// Which context allows this?\nconst data = await fetch('/api/data');",
    "options": [
      "In any JavaScript file",
      "Only in ES modules (.mjs or type='module')",
      "Only inside async functions",
      "In both ES modules and CommonJS"
    ],
    "correctAnswer": 1,
    "explanation": "Top-level await is only available in ES modules. It allows you to use await at the module's top level without wrapping in an async function.",
    "tags": ["async", "top-level-await", "esm"],
    "created_at": 1733046216000
  },
  {
    "id": "q18_async_concurrent_limit",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Concurrent Execution Limit",
    "question": "What is logged, and in what order?",
    "code": "async function processWithLimit(items, limit, fn) {\n  const results = [];\n  const executing = [];\n  \n  for (const item of items) {\n    const p = fn(item).then(r => {\n      executing.splice(executing.indexOf(p), 1);\n      return r;\n    });\n    results.push(p);\n    executing.push(p);\n    \n    if (executing.length >= limit) {\n      await Promise.race(executing);\n    }\n  }\n  return Promise.all(results);\n}\n\nconst delay = ms => new Promise(r => setTimeout(r, ms));\nconst fn = async (x) => { await delay(100); console.log(x); return x; };\n\nprocessWithLimit([1, 2, 3, 4], 2, fn);",
    "options": [
      "1, 2, 3, 4 (sequential)",
      "1, 2 then 3, 4 (in pairs)",
      "Non-deterministic but max 2 concurrent",
      "4, 3, 2, 1 (reverse)"
    ],
    "correctAnswer": 2,
    "explanation": "This pattern limits concurrency. At most 2 items are processed simultaneously. The exact order within groups may vary based on timing.",
    "tags": ["async", "concurrency", "pattern"],
    "created_at": 1733046217000
  },
  {
    "id": "q19_async_abort_controller",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "AbortController with Fetch",
    "question": "What happens when this code runs?",
    "code": "const controller = new AbortController();\nconst signal = controller.signal;\n\nsetTimeout(() => controller.abort(), 50);\n\nfetch('/api/data', { signal })\n  .then(r => console.log('Success'))\n  .catch(e => console.log(e.name));",
    "options": [
      "Success",
      "AbortError",
      "TimeoutError",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "AbortController allows canceling fetch requests. After 50ms, abort() is called, causing the fetch to reject with an AbortError.",
    "tags": ["async", "abort-controller", "fetch"],
    "created_at": 1733046218000
  },
  {
    "id": "q20_async_promise_resolve_thenable",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Promise.resolve with Nested Promise",
    "question": "What is the output?",
    "code": "const p1 = Promise.resolve(Promise.resolve(42));\nconst p2 = Promise.resolve({ then: (cb) => cb(100) });\n\nPromise.all([p1, p2]).then(console.log);",
    "options": [
      "[Promise, { then: fn }]",
      "[42, 100]",
      "[Promise, 100]",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "Promise.resolve unwraps nested promises and thenables. p1 resolves to 42 (inner promise unwrapped). p2's thenable is called, resolving to 100.",
    "tags": ["async", "promise.resolve", "thenable"],
    "created_at": 1733046219000
  },
  {
    "id": "q21_async_promise_all_reject_order",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Promise.all Rejection",
    "question": "What will be logged?",
    "code": "const promise1 = Promise.resolve('First');\nconst promise2 = Promise.resolve('Second');\nconst promise3 = Promise.reject('Third');\nconst promise4 = Promise.resolve('Fourth');\n\nconst runPromises = async () => {\n  const res1 = await Promise.all([promise1, promise2]);\n  const res2 = await Promise.all([promise3, promise4]);\n  return [res1, res2];\n};\n\nrunPromises()\n  .then(res => console.log(res))\n  .catch(err => console.log(err));",
    "options": [
      "[['First', 'Second'], ['Fourth']]",
      "[['First', 'Second'], ['Third', 'Fourth']]",
      "[['First', 'Second']]",
      "'Third'"
    ],
    "correctAnswer": 3,
    "explanation": "Promise.all rejects if any promise rejects. res1 succeeds with ['First', 'Second']. res2 throws because promise3 rejects. 'Third' is caught.",
    "tags": ["async", "promise.all", "rejection"],
    "created_at": 1733046220000
  },
  {
    "id": "q22_async_return_await",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "return vs return await",
    "question": "What is the difference?",
    "code": "async function f1() {\n  try {\n    return Promise.reject('error');\n  } catch (e) {\n    return 'caught';\n  }\n}\n\nasync function f2() {\n  try {\n    return await Promise.reject('error');\n  } catch (e) {\n    return 'caught';\n  }\n}\n\nf1().then(console.log).catch(console.log);\nf2().then(console.log).catch(console.log);",
    "options": [
      "'caught', 'caught'",
      "'error', 'caught'",
      "'error', 'error'",
      "'caught', 'error'"
    ],
    "correctAnswer": 1,
    "explanation": "return Promise.reject() doesn't trigger catch - the promise is returned directly. return await waits and triggers the local catch block.",
    "tags": ["async", "return-await", "error-handling"],
    "created_at": 1733046221000
  },
  {
    "id": "q23_async_foreach_await",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "forEach with async",
    "question": "What will be logged first?",
    "code": "const nums = [1, 2, 3];\n\nnums.forEach(async (num) => {\n  const result = await Promise.resolve(num * 2);\n  console.log(result);\n});\n\nconsole.log('Done');",
    "options": [
      "2, 4, 6, 'Done'",
      "'Done', 2, 4, 6",
      "'Done' (then 2, 4, 6 in parallel)",
      "2, 'Done', 4, 6"
    ],
    "correctAnswer": 2,
    "explanation": "forEach doesn't await async callbacks. It fires all async functions immediately. 'Done' logs first, then results in non-deterministic order.",
    "tags": ["async", "foreach", "gotcha"],
    "created_at": 1733046222000
  },
  {
    "id": "q24_async_promise_resolve_chain",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise.resolve Chain",
    "question": "What is the output?",
    "code": "Promise.resolve(5)\n  .then(x => x * 2)\n  .then(x => {\n    throw new Error('oops');\n  })\n  .then(x => x + 1)\n  .catch(e => 0)\n  .then(x => console.log(x));",
    "options": [
      "11",
      "0",
      "Error: oops",
      "undefined"
    ],
    "correctAnswer": 1,
    "explanation": "5*2=10, then throws error. Error skips next .then(). catch returns 0. Final .then() logs 0.",
    "tags": ["async", "promise-chain", "error"],
    "created_at": 1733046223000
  },
  {
    "id": "q25_async_microtask_order",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Microtask Queue Order",
    "question": "What is the output order?",
    "code": "async function async1() {\n  console.log('async1 start');\n  await async2();\n  console.log('async1 end');\n}\n\nasync function async2() {\n  console.log('async2');\n}\n\nconsole.log('script start');\nasync1();\nconsole.log('script end');",
    "options": [
      "script start, async1 start, async2, script end, async1 end",
      "script start, script end, async1 start, async2, async1 end",
      "script start, async1 start, async2, async1 end, script end",
      "script start, async1 start, script end, async2, async1 end"
    ],
    "correctAnswer": 0,
    "explanation": "sync code runs first. async1 logs, calls async2 (logs), await pauses. 'script end' logs. Then microtask 'async1 end' runs.",
    "tags": ["async", "microtask", "execution-order"],
    "created_at": 1733046224000
  },
  {
    "id": "q26_async_promise_constructor_sync",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Promise Constructor Executor",
    "question": "What will be logged?",
    "code": "const promise = new Promise((resolve, reject) => {\n  console.log(1);\n  resolve(2);\n  console.log(3);\n});\n\npromise.then(val => console.log(val));",
    "options": [
      "1, 2, 3",
      "1, 3, 2",
      "1, 2",
      "2, 1, 3"
    ],
    "correctAnswer": 1,
    "explanation": "Promise executor runs synchronously. 1 logs, resolve queues callback, 3 logs. Then microtask (2) runs.",
    "tags": ["async", "promise", "executor"],
    "created_at": 1733046225000
  },
  {
    "id": "q27_async_sleep_implementation",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "Sleep Function",
    "question": "What is logged and when?",
    "code": "const sleep = ms => new Promise(r => setTimeout(r, ms));\n\nasync function test() {\n  console.log('start');\n  await sleep(1000);\n  console.log('end');\n}\n\ntest();\nconsole.log('after call');",
    "options": [
      "start, end, after call (all immediate)",
      "start, after call, end (end after 1s)",
      "start, after call, end (all immediate)",
      "after call, start, end"
    ],
    "correctAnswer": 1,
    "explanation": "'start' logs, await pauses test(). 'after call' logs immediately. After 1 second, 'end' logs.",
    "tags": ["async", "sleep", "timing"],
    "created_at": 1733046226000
  },
  {
    "id": "q28_async_catch_rethrow",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Catch and Rethrow",
    "question": "What is logged?",
    "code": "Promise.reject('error')\n  .catch(e => {\n    console.log('caught:', e);\n    throw e;\n  })\n  .then(() => console.log('then'))\n  .catch(() => console.log('caught again'));",
    "options": [
      "caught: error",
      "caught: error, then",
      "caught: error, caught again",
      "then, caught again"
    ],
    "correctAnswer": 2,
    "explanation": "First catch logs 'caught: error' then rethrows. Rethrown error skips .then() and hits second .catch().",
    "tags": ["async", "catch", "rethrow"],
    "created_at": 1733046227000
  },
  {
    "id": "q29_async_promise_any_all_reject",
    "category": "async",
    "difficulty": "hard",
    "type": "code-output",
    "title": "Promise.any All Reject",
    "question": "What happens?",
    "code": "Promise.any([\n  Promise.reject('a'),\n  Promise.reject('b'),\n  Promise.reject('c')\n])\n  .then(v => console.log('value:', v))\n  .catch(e => console.log('errors:', e.errors));",
    "options": [
      "value: 'a'",
      "errors: ['a', 'b', 'c']",
      "errors: 'a'",
      "Unhandled rejection"
    ],
    "correctAnswer": 1,
    "explanation": "Promise.any rejects with AggregateError when all promises reject. e.errors contains all rejection reasons ['a', 'b', 'c'].",
    "tags": ["async", "promise.any", "aggregateerror"],
    "created_at": 1733046228000
  },
  {
    "id": "q30_async_settimeout_promise",
    "category": "async",
    "difficulty": "medium",
    "type": "code-output",
    "title": "setTimeout vs Promise Order",
    "question": "What is the output order?",
    "code": "setTimeout(() => console.log('timeout'), 0);\n\nPromise.resolve()\n  .then(() => console.log('promise1'))\n  .then(() => console.log('promise2'));\n\nconsole.log('sync');",
    "options": [
      "sync, timeout, promise1, promise2",
      "sync, promise1, promise2, timeout",
      "sync, promise1, timeout, promise2",
      "timeout, sync, promise1, promise2"
    ],
    "correctAnswer": 1,
    "explanation": "Sync code first ('sync'). Microtasks (promises) next ('promise1', 'promise2'). Macrotasks (setTimeout) last ('timeout').",
    "tags": ["async", "settimeout", "microtask"],
    "created_at": 1733046229000
  }
]

